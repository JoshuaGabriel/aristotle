#! /usr/bin/env bash

cmd_dir=$(dirname "$0") || exit 1
source "$cmd_dir/utilities" || exit 1

################################################################################
#
################################################################################

panic()
{
	echo "ERROR: $@"
	exit 4
}

get_nth_last_line()
{
	local n="$1"
	shift 1
	cat "$@" | tail -n "$n" | head -n 1
}

get_nth_word()
{
	if [ $# -ne 1 ]; then
		return 1
	fi
	awk -v n="$1" '{if (n <= NF) {print $n;} else {exit 1;}}' -
}

quote_test_name()
{
	# Escape the following characters with a backslash:
	# asterisk, left/right square bracket, plus, comma
	echo "$1" | \
	  sed -e 's/\*/\\*/g' | \
	  sed -e 's/\[/\\[/g' | \
	  sed -e 's/\]/\\]/g' | \
	  sed -e 's/\+/\\+/g' | \
	  sed -e 's/,/\\,/g'
	# sed -e 's/|/\\|/g'
	# sed -e 's/\./\\./g'
}

usage()
{
	echo "$@"
	cat <<- EOF
	usage:
	$0 [options]

	options:
	-c \$command
	    Set the program to run to \$command.
	-t \$timeout
	    Set the timeout to \$timeout.
	-r
	    Enable the saving of the results.
	-D \$debug_level
	    Set the debug level to \$debug_level.

	exit status:
	0 ... Catch2 application ran to completion and all tests passed
	1 ... Catch2 application ran to completion but some tests failed
	2 ... Catch2 application did not run to completion but summary generated
	3 ... Catch2 application did not run to completion and no summary generated
	4 ... other fatal error
	5 ... bad usage
	EOF
	exit 5
}

################################################################################
#
################################################################################

ari_timeout="$cmd_dir/ari_timeout"

user="$whoami"
host=$(hostname)
tmp_dir=/tmp/ari_run_catch_app-$user@$host-$$
console_file="$tmp_dir/console"
log_file="$tmp_dir/log"
debug_level=${ARI_DEBUG_LEVEL:-0}
tests_file="$tmp_dir/tests"

################################################################################
#
################################################################################

command=
run_individually=0
result=0
result_file="$ARI_TEST_RESULT_FILE"
timeout=

while getopts AID:c:rt:f: opt; do
	case $opt in
	A)
		run_individually=0;;
	I)
		run_individually=1;;
	c)
		command="$OPTARG";;
	t)
		timeout="$OPTARG";;
	r)
		result=1;;
	f)
		result=1; result_file="$OPTARG";;
	D)
		debug_level="$OPTARG";;
	\?)
		usage
		break;;
	esac
done
shift $((OPTIND - 1))

if [ "$result" -ne 0 ]; then
	if [ -z "$result_file" ]; then
		panic "no result file specified"
	fi
fi

if [ -z "$command" ]; then
	panic "no command specified"
fi

if [ "$debug_level" -ge 100 ]; then
	set -xv
fi

################################################################################
#
################################################################################

mkdir -p "$tmp_dir" || panic "cannot make directory $tmp_dir"

# Determine the total number of test cases.
# A Catch2 application should generate output like the following:
# All available test cases:
# [1 line per test case]
# 10 test cases
# [blank line]
buffer=$("$command" -r console -l 2> /dev/null | get_nth_last_line 2)
echo "$buffer" | grep -q -e '[0-9]\+.\+test cases' || \
  panic "invalid output generated by Catch2 application"
num_tests=$(echo "$buffer" | get_nth_word 1) || \
  panic "cannot extract number of test cases"

# Obtain a list of the tests.
# Catch2 sets the exit status to the number of test cases clamped at 255.
# Due to this braindamage, we cannot rely on the exit status to know if
# this list of tests was successfully output.
# So, we simply check if the number of tests listed matches the number
# of tests obtained from the query above.
"$command" --list-test-names-only > "$tests_file"
mapfile -t all_tests < "$tests_file" || \
  panic "cannot read tests file"
if [ "${#all_tests[@]}" -ne "$num_tests" ]; then
	panic "cannot get tests"
fi

if [ "$debug_level" -ge 1 ]; then
	for test in "${all_tests[@]}"; do
		echo "$test"
	done
fi

tests=("${all_tests[@]}")
cum_total_tests=0
cum_failed_tests=0
cum_passed_tests=0
cum_total_assertions=0
cum_failed_assertions=0
cum_passed_assertions=0
cum_missing_summaries=0
num_runs=0
cum_extra_tests=0

if [ "$run_individually" -ne 0 ]; then
	tests=("${all_tests[@]}")
else
	tests=("__all_tests__")
fi

for test in "${tests[@]}"; do

	if [ "$test" = "__all_tests__" ]; then
		app_args=()
	else
		app_args=()
		app_args+=("$(quote_test_name "$test")")
	fi

	if [ -e "$console_file" ]; then
		rm -f "$console_file" || panic "cannot remove file $console_file"
	fi

	# Run the test application.
	if [ -n "$timeout" ]; then
		# Run the test application with a timeout.
		args=(-t "$timeout" -k 10 "$command" -r console "${app_args[@]}")
		#echo "Running $ari_timeout ${args[@]}"
		"$ari_timeout" "${args[@]}" > "$console_file" 2> /dev/null
		app_exit_status=$?
	else
		# Run the test application without a timeout.
		args=(-r console "${app_args[@]}")
		#echo "Running $command ${args[@]}"
		"$command" "${args[@]}" > "$console_file" 2> /dev/null
		app_exit_status=$?
	fi
	num_runs=$((num_runs + 1))

	if [ "$app_exit_status" -ne 0 ]; then

		# Extract the summary of the test results.
		# If any tests fail, the output should resemble:
		# test cases:  6 |  5 passed | 1 failed
		# assertions: 84 | 80 passed | 4 failed
		# [blank line]
		# It might also look like:
		# test cases: 1 | 1 failed
		# assertions: 4 | 4 failed
		# [blank line]
		tests_buffer=$(get_nth_last_line 3 "$console_file") || \
		  panic "cannot get test cases summary line"
		assertions_buffer=$(get_nth_last_line 2 "$console_file") || \
		  panic "cannot get assertions summary line"
		if [ "$debug_level" -ge 1 ]; then
			eecho "=========="
			eecho "$tests_buffer"
			eecho "$assertions_buffer"
			eecho "=========="
		fi

		# Check for text that generally resembles a test-results summary.
		has_summary=1
		echo "$tests_buffer" | grep -q -E '^test cases:[[:space:]]+' || \
		  has_summary=0
		echo "$assertions_buffer" | grep -q -E '^assertions:[[:space:]]+' || \
		  has_summary=0

		if [ "$has_summary" -ne 0 ]; then

			# Determine format of summary.
			tests_format=
			assertions_format=
			echo "$tests_buffer" | grep -q \
			  -E '^test cases:[[:space:]]+[0-9]*[[:space:]]+\|[[:space:]]+[0-9]*[[:space:]]+passed[[:space:]]+|[[:space:]]+[0-9]*[[:space:]]+failed$' && \
			  tests_format=passed_failed
			echo "$tests_buffer" | grep -q \
			  -E '^test cases:[[:space:]]+[0-9]*[[:space:]]+\|[[:space:]]+[0-9]*[[:space:]]+failed$' && \
			  tests_format=failed
			echo "$assertions_buffer" | grep -q \
			  -E '^assertions:[[:space:]]+[0-9]*[[:space:]]+\|[[:space:]]+[0-9]*[[:space:]]+passed[[:space:]]+|[[:space:]]+[0-9]*[[:space:]]+failed$' && \
			  assertions_format=passed_failed
			echo "$assertions_buffer" | grep -q \
			  -E '^assertions:[[:space:]]+[0-9]*[[:space:]]+\|[[:space:]]+[0-9]*[[:space:]]+failed$' && \
			  assertions_format=failed

			# Extract test information from summary.
			case "$tests_format" in
			passed_failed)
				total_tests=$(echo "$tests_buffer" | get_nth_word 3) || \
				  panic "cannot get total tests"
				passed_tests=$(echo "$tests_buffer" | get_nth_word 5) || \
				  panic "cannot get passed tests"
				failed_tests=$(echo "$tests_buffer" | get_nth_word 8) || \
				  panic "cannot get failed tests"
				;;
			failed)
				total_tests=$(echo "$tests_buffer" | get_nth_word 3) || \
				  panic "cannot get total tests"
				passed_tests=0
				failed_tests=$(echo "$tests_buffer" | get_nth_word 5) || \
				  panic "cannot get failed tests"
				;;
			*)
				panic "unexpected tests summary format"
				;;
			esac

			# Extract assertion information from summary.
			case "$assertions_format" in
			passed_failed)
				total_assertions=$(echo "$assertions_buffer" | \
				  get_nth_word 2) || \
				  panic "cannot get total assertions"
				passed_assertions=$(echo "$assertions_buffer" | \
				  get_nth_word 4) || \
				  panic "cannot get passed assertions"
				failed_assertions=$(echo "$assertions_buffer" | \
				  get_nth_word 7) || \
				  panic "cannot get failed assertions"
				;;
			failed)
				total_assertions=$(echo "$assertions_buffer" | \
				  get_nth_word 2) || \
				  panic "cannot get total assertions"
				passed_assertions=0
				failed_assertions=$(echo "$assertions_buffer" | \
				  get_nth_word 4) || \
				  panic "cannot get failed assertions"
				;;
			*)
				panic "unexpected assertions summary format"
				;;
			esac

		fi

	else

		# If all tests pass, then the output should resemble:
		# All tests passed (723 assertions in 22 test cases)
		# [blank line]
		# The words assertions and cases may be singular.
		# All tests passed (1 assertion in 1 test case)
		buffer=$(get_nth_last_line 2 "$console_file") || \
		  panic "cannot get status line"
		if [ "$debug_level" -ge 1 ]; then
			eecho "=========="
			eecho "$buffer"
			eecho "=========="
		fi
		has_summary=1
		echo "$buffer" | \
		  grep -q \
		  -E '^All tests passed \([0-9]*[[:space:]]+(assertions|assertion) in[[:space:]]+[0-9]*[[:space:]]+test (cases|case)\)$' || \
		  has_summary=0
		if [ "$has_summary" -ne 0 ]; then
			buffer=$(echo "$buffer" | tr '()' '  ')
			total_assertions=$(echo "$buffer" | get_nth_word 4) || \
			  panic "cannot get total assertions"
			total_tests=$(echo "$buffer" | get_nth_word 7) || \
			  panic "cannot get total tests"
			passed_tests="$total_tests"
			passed_assertions="$total_assertions"
			failed_tests=0
			failed_assertions=0
		else
			panic "cannot parse summary of test results"
		fi

	fi

	if [ "$has_summary" -ne 0 ]; then
		if [ "$run_individually" -ne 0 ]; then
			if [ "$total_tests" -ne 1 ]; then
				eecho "more than one test run per invocation for test $test"
				cum_extra_tests=$((extra_tests + total_tests - 1))
			fi
		fi
		cum_total_tests=$((cum_total_tests + total_tests))
		cum_passed_tests=$((cum_passed_tests + passed_tests))
		cum_failed_tests=$((cum_failed_tests + failed_tests))
		cum_total_assertions=$((cum_total_assertions + total_assertions))
		cum_passed_assertions=$((cum_passed_assertions + passed_assertions))
		cum_failed_assertions=$((cum_failed_assertions + failed_assertions))
	else
		cum_missing_summaries=$((cum_missing_summaries + 1))
	fi

	if [ "$debug_level" -ge 2 ]; then
		eecho "=========="
		eecho "test name: $test"
		eecho "has summary: $has_summary"
		if [ "$has_summary" -ne 0 ]; then
			eecho "summary format: $tests_format $assertions_format"
			eecho "total tests: $total_tests"
			eecho "passed tests: $passed_tests"
			eecho "failed tests: $failed_tests"
			eecho "total assertions: $total_assertions"
			eecho "passed assertions: $passed_assertions"
			eecho "failed assertions: $failed_assertions"
		fi
		eecho "=========="
	fi

	if [ "$app_exit_status" -ne 0 ]; then
		cat <<- EOF
		============================================================
		Test Name: $test
		============================================================
		EOF
		[ $? -eq 0 ] || panic "output failed"
	fi

	if [ "$has_summary" -eq 0 ]; then
		cat <<- EOF
		WARNING:
		The Catch2 test application was violently terminated before
		generating the summary of the test results.
		The most likely cause is that the code being tested trashed
		the stack (e.g., stack overflow or stack corruption).

		EOF
		[ $? -eq 0 ] || panic "output failed"
	fi

	if [ "$app_exit_status" -ne 0 ]; then
		cat "$console_file" || panic "cannot copy log file"
	fi

done

if [ "$debug_level" -ge 1 ]; then
	eecho "total tests: $cum_total_tests"
	eecho "passed tests: $cum_passed_tests"
	eecho "failed tests: $cum_failed_tests"
	eecho "total assertions: $cum_total_assertions"
	eecho "passed assertions: $cum_passed_assertions"
	eecho "failed assertions: $cum_failed_assertions"
fi

failed_tests_message="$cum_failed_tests/$cum_total_tests"
failed_assertions_message="$cum_failed_assertions/$cum_total_assertions"
missing_summaries_message="$cum_missing_summaries/$num_runs"
if [ "$cum_missing_summaries" -gt 0 -o "$cum_failed_tests" -gt 0 ]; then
	if [ "$cum_missing_summaries" -gt 0 ]; then
		if [ "$cum_missing_summaries" -ge "$num_runs" ]; then
			result_message="INC[$cum_missing_summaries/$num_runs],$cum_failed_tests/$cum_total_tests,$cum_failed_assertions/$cum_total_assertions"
			status_message="FAIL (NO SUMMARY)"
			exit_status=3
		else
			result_message="INC[$cum_missing_summaries/$num_runs],$cum_failed_tests/$cum_total_tests,$cum_failed_assertions/$cum_total_assertions"
			status_message="FAIL (INCOMPLETE SUMMARY)"
			exit_status=2
		fi
	else
		result_message="COM,$cum_failed_tests/$cum_total_tests,$cum_failed_assertions/$cum_total_assertions"
		status_message="FAIL (COMPLETE SUMMARY)"
		exit_status=1
	fi
else
	result_message="PASS,0/$cum_total_tests,0/$cum_total_assertions"
	status_message="PASS"
	exit_status=0
fi

if [ "$result" -ne 0 ]; then
	echo "$result_message" > "$result_file" || \
	  panic "cannot create result file"
fi

if [ "$run_individually" -ne 0 ]; then
	mode_message="One test program invocation per test case"
else
	mode_message="One test program invocation for all test cases"
fi

################################################################################
#
################################################################################

#echo "$result_message"

################################################################################
#
################################################################################

cat <<- EOF

============================================================

LEGEND
======

PASS
The Catch2 test application was able to run the full set of test cases and
all of the test cases passed.

FAIL (COMPLETE SUMMARY)
The Catch2 test application was able to run the full set of test cases but
some test cases failed.
In some cases, the Catch2 test application may have been forced to exit
slightly early, but the application was still able to generate a summary of
the test results before exiting.

FAIL (INCOMPLETE SUMMARY)
Some (but not all) of the times that the Catch2 test application was run,
the application was terminated before being able to generate a summary
of the test results.

FAIL (NO SUMMARY)
Every time that the Catch2 test application was run, the application was
terminated before being able to generate a summary of the test results.
In this case, most test results are likely to be unknown.

Note:
If the Catch2 test application was forced to exit before processing all
of the test cases to be run, this is typically caused by a signal being
generated by the code being tested (such as a floating-point exception
or segmentation fault) that does not prevent the test application from
exiting gracefully (i.e., after having printed the summary of the test
results).

Note:
If the Catch2 test application terminates before being able to generate
a summary of the test results, this is likely due to the code being
tested trashing the stack (e.g., stack overflow or stack corruption).

SUMMARY OF TEST RESULTS
=======================

Status: $status_message
Number of test cases: ${#all_tests[@]}
Mode: $mode_message
Test program invocations: $num_runs
Missing summaries: $missing_summaries_message
Failed test cases: $failed_tests_message
Failed assertions: $failed_assertions_message
Result: $result_message
EOF
[ $? -eq 0 ] || panic "output failed"

if [ "$cum_extra_tests" -ne 0 ]; then
	cat <<- EOF
	WARNING: Some test cases were repeated (due to Catch2 bug?).
	Repeated test cases: $cum_extra_tests
	EOF
fi

################################################################################
# Cleanup
################################################################################

rm -f "$tests_file"
rm -f "$console_file"
rmdir "$tmp_dir"

################################################################################
# Exit
################################################################################

exit "$exit_status"
