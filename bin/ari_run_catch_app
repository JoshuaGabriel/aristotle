#! /usr/bin/env bash

cmd_dir=$(dirname "$0") || exit 1
source "$cmd_dir/utilities" || exit 1

################################################################################
#
################################################################################

panic()
{
	echo "ERROR: $@"
	exit 4
}

get_nth_last_line()
{
	local n="$1"
	shift 1
	cat "$@" | tail -n "$n" | head -n 1
}

get_nth_word()
{
	if [ $# -ne 1 ]; then
		return 1
	fi
	awk -v n="$1" '{if (n <= NF) {print $n;} else {exit 1;}}' -
}

usage()
{
	echo "$@"
	cat <<- EOF
	usage:
	$0 [options]

	options:
	-c \$command
	    Set the program to run to \$command.
	-t \$timeout
	    Set the timeout to \$timeout.
	-r
	    Enable the saving of the results.
	-D \$debug_level
	    Set the debug level to \$debug_level.

	exit status:
	0 ... Catch2 application ran to completion and all tests passed
	1 ... Catch2 application ran to completion but some tests failed
	2 ... Catch2 application did not run to completion but exited gracefully
	3 ... Catch2 application did not run to completion and died violently
	4 ... other fatal error
	5 ... bad usage
	EOF
	exit 5
}

################################################################################
#
################################################################################

ari_timeout="$cmd_dir/ari_timeout"

user="$whoami"
host=$(hostname)
tmp_dir=/tmp/ari_run_catch_app-$user@$host-$$
console_file="$tmp_dir/console_file"
xml_file="$tmp_dir/xml_file"
debug_level=${ARI_DEBUG_LEVEL:-0}

################################################################################
#
################################################################################

command=
result=0
result_file="$ARI_TEST_RESULT_FILE"
timeout=

while getopts D:c:rt:f: opt; do
	case $opt in
	c)
		command="$OPTARG";;
	t)
		timeout="$OPTARG";;
	r)
		result=1;;
	f)
		result=1; result_file="$OPTARG";;
	D)
		debug_level="$OPTARG";;
	\?)
		usage
		break;;
	esac
done
shift $((OPTIND - 1))

if [ "$result" -ne 0 ]; then
	if [ -z "$result_file" ]; then
		panic "no result file specified"
	fi
fi

if [ -z "$command" ]; then
	panic "no command specified"
fi

################################################################################
#
################################################################################

mkdir -p "$tmp_dir" || panic "cannot make directory $tmp_dir"

# Determine the total number of test cases.
# A Catch2 application should generate output like the following:
# All available test cases:
# [1 line per test case]
# 10 test cases
# [blank line]
buffer=$("$command" -r console -l 2> /dev/null | get_nth_last_line 2)
echo "$buffer" | grep -q -e '[0-9]\+.\+test cases' || \
  panic "invalid output generated by Catch2 application"
num_tests=$(echo "$buffer" | get_nth_word 1) || \
  panic "cannot extract number of test cases"
if [ "$num_tests" -ge 128 ]; then
	eecho "since more than 127 test cases, cannot rely on Catch2 app exit status"
fi

# Run the test application.
if [ -n "$timeout" ]; then
	# Run the test application with a timeout.
	"$ari_timeout" -t "$timeout" -k 10 "$command" -r console \
	  > "$console_file" 2> /dev/null
	app_exit_status=$?
else
	# Run the test application without a timeout.
	"$command" -r console > "$console_file" 2> /dev/null
	app_exit_status=$?
fi

completed=0
has_summary=0
if [ "$app_exit_status" -ne 0 ]; then

	# Extract the summary of the test results.
	# If any tests fail, the output should resemble:
	# test cases:  6 |  5 passed | 1 failed
	# assertions: 84 | 80 passed | 4 failed
	# [blank line]
	test_cases_buffer=$(get_nth_last_line 3 "$console_file") || \
	  panic "cannot get test cases summary line"
	assertions_buffer=$(get_nth_last_line 2 "$console_file") || \
	  panic "cannot get assertions summary line"
	has_summary=1
	echo "$test_cases_buffer" | grep -q \
	  -e '^test cases:[[:space:]]\+[0-9]*[[:space:]]\+|[[:space:]]\+[0-9]*[[:space:]]\+passed[[:space:]]\+|[[:space:]]\+[0-9]*[[:space:]]\+failed$' || \
	  has_summary=0
	echo "$assertions_buffer" | grep -q \
	  -e '^assertions:[[:space:]]\+[0-9]*[[:space:]]\+|[[:space:]]\+[0-9]*[[:space:]]\+passed[[:space:]]\+|[[:space:]]\+[0-9]*[[:space:]]\+failed$' || \
	  has_summary=0

	if [ "$has_summary" -ne 0 ]; then
		total_tests=$(echo "$test_cases_buffer" | get_nth_word 3) || \
		  panic "cannot get total tests"
		passed_tests=$(echo "$test_cases_buffer" | get_nth_word 5) || \
		  panic "cannot get passed tests"
		failed_tests=$(echo "$test_cases_buffer" | get_nth_word 8) || \
		  panic "cannot get failed tests"
		total_assertions=$(echo "$assertions_buffer" | get_nth_word 2) || \
		  panic "cannot get total assertions"
		passed_assertions=$(echo "$assertions_buffer" | get_nth_word 4) || \
		  panic "cannot get passed assertions"
		failed_assertions=$(echo "$assertions_buffer" | get_nth_word 7) || \
		  panic "cannot get failed assertions"
		if [ "$total_tests" -eq "$num_tests" ]; then
			completed=1
		else
			completed=0
		fi
	else
		completed=0

		# Re-run the test application reporting successful tests.
		if [ -n "$timeout" ]; then
			# Run the test application with a timeout.
			"$ari_timeout" -t "$timeout" -k 10 "$command" -r xml -s \
			  > "$xml_file" 2> /dev/null
			alt_app_exit_status=$?
		else
			# Run the test application without a timeout.
			"$command" -r xml -s > "$xml_file" 2> /dev/null
			alt_app_exit_status=$?
		fi
		eecho "fallback app exit status $alt_app_exit_status"

		# Extract the number of test cases run.
		total_tests=$(cat "$xml_file" | grep -e '<TestCase.*>' | wc -l) || \
		  panic "cannot extract number of test cases"
		total_tests="$total_tests"

		# Extract the number of assertions tested.
		total_assertions=$(cat "$xml_file" | grep -e '<Expression.*>' | \
		  wc -l) || \
		  panic "cannot extract number of assertions"
		total_assertions="$total_assertions"

		passed_tests=""
		failed_tests=""
		passed_assertions=""
		failed_assertions=""
	fi

	if [ "$completed" -eq 1 ]; then
		result_message="COM,$failed_assertions/$total_assertions,$failed_tests/$total_tests"
	else
		if [ "$has_summary" -ne 0 ]; then
			result_message="INC,$failed_assertions/$total_assertions,$failed_tests/$total_tests"
		else
			result_message="INC,?/${total_assertions}?,?/${total_tests}?"
		fi
	fi
else
	completed=1

	# If all tests pass, then the output should resemble:
	# All tests passed (723 assertions in 22 test cases)
	# [blank line]
	buffer=$(get_nth_last_line 2 "$console_file") || \
	  panic "cannot get status line"
	has_summary=1
	echo "$buffer" | grep -q \
	  -e '^All tests passed ([0-9]*[[:space:]]\+assertions in[[:space:]]\+[0-9]*[[:space:]]\+test cases)$' || \
	  has_summary=0
	if [ "$has_summary" -ne 0 ]; then
		buffer=$(echo "$buffer" | tr '()' '  ')
		total_assertions=$(echo "$buffer" | get_nth_word 4) || \
		  panic "cannot get total assertions"
		total_tests=$(echo "$buffer" | get_nth_word 7) || \
		  panic "cannot get total tests"
		result_message="PASS,0/$total_assertions,0/$total_tests"
	else
		panic "cannot parse summary of test results"
	fi
fi

if [ "$result" -ne 0 ]; then
	echo "$result_message" > "$result_file" || \
	  panic "cannot create result file"
fi

if [ "$debug_level" -ge 1 ]; then
	eecho "completed: $completed"
	eecho "has summary: $has_summary"
	eecho "number of tests: $num_tests"
	eecho "total tests: $total_tests"
	eecho "passed tests: $passed_tests"
	eecho "failed tests: $failed_tests"
	eecho "total assertions: $total_assertions"
	eecho "passed assertions: $passed_assertions"
	eecho "failed assertions: $failed_assertions"
fi

################################################################################
#
################################################################################

if [ "$completed" -ne 0 ]; then
	if [ "$app_exit_status" -eq 0 ]; then
		status_message="PASS"
		failed_assertions_message="0/$total_assertions"
		failed_tests_message="0/$total_tests"
		exit_status=0
	else
		status_message="FAIL (COMPLETE WITH SUMMARY)"
		failed_assertions_message="$failed_assertions/$total_assertions"
		failed_tests_message="$failed_tests/$total_tests"
		exit_status=1
	fi
else
	if [ "$has_summary" -ne 0 ]; then
		status_message="FAIL (INCOMPLETE WITH SUMMARY)"
		failed_assertions_message="$failed_assertions/$total_assertions"
		failed_tests_message="$failed_tests/$total_tests"
		exit_status=2
	else
		status_message="FAIL (INCOMPLETE WITHOUT SUMMARY)"
		failed_assertions_message="?/${total_assertions}?"
		failed_tests_message="?/${total_tests}?"
		exit_status=3
	fi
fi

################################################################################
#
################################################################################

if [ "$has_summary" -eq 0 ]; then
	cat <<- EOF
	============================================================
	WARNING:
	The Catch2 test application was violently terminated before
	generating the summary of the test results.
	The most likely cause is that the code being tested trashed
	the stack (e.g., stack overflow or stack corruption).
	============================================================

	EOF
	[ $? -eq 0 ] || panic "output failed"
fi

cat "$console_file" || panic "cannot copy log file"

cat <<- EOF

============================================================

LEGEND
======

PASS
The Catch2 test application was able to run the full set of test cases and
all of the test cases passed.

FAIL (COMPLETE WITH SUMMARY)
The Catch2 test application was able to run the full set of test cases but
some test cases failed.

FAIL (INCOMPLETE WITH SUMMARY)
The Catch2 test application was forced to exit before processing the full
set of test cases.  The application was able to generate the test-results
summary before exiting.  This situation is typically caused by a signal being
generated by the code being tested (such as a floating-point exception or
segmentation fault) that does not prevent the test application from exiting
gracefully (i.e., after having printed the test-results summary).

FAIL (INCOMPLETE WITHOUT SUMMARY)
The Catch2 test application was violently terminated before generating
the test-results summary.  This is most likely caused by the code being
tested trashing the stack (e.g., stack overflow or stack corruption).
In this case, the number of test cases and number of assertions actually
tested cannot be determined reliably.  The numbers provided are an estimate.

SUMMARY OF TEST RESULTS
=======================

Status: $status_message
Failed assertions: $failed_assertions_message
Failed tests: $failed_tests_message
EOF
[ $? -eq 0 ] || panic "output failed"

################################################################################
# Cleanup
################################################################################

rm -f "$console_file"
rm -f "$xml_file"
rmdir "$tmp_dir"

################################################################################
# Exit
################################################################################

exit "$exit_status"
