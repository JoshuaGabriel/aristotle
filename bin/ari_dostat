#! /usr/bin/env bash

# __START_OF_LICENSE__
# 
# Copyright (c) 2019 Michael D. Adams
# All rights reserved.
# 
# This file is part of the Aristotle software.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3,
# or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; see the file LICENSE.  If not,
# see <http://www.gnu.org/licenses/>.
# 
# __END_OF_LICENSE__

eecho()
{
	echo "$@" 1>&2
}

panic()
{
	echo "ERROR: $@" 1>&2
	exit 1
}

usage()
{
	echo "$@"
	cat <<- EOF
	usage:
	$0 [options]

	options:
	-d \$work_dir
	-r \$repo_regex
	-o \$organization

	examples:
	$0 -d dostat -o uvic-seng475 -r 'tools-.*'
	EOF
	exit 2
}

cmd_dir=$(dirname "$0") || panic "cannot get command directory"
ari_hub="$cmd_dir/ari_hub"

debug_level="${ARI_DEBUG_LEVEL:-0}"
organization=
repo_regex=".*"
package_regex=".*"
work_dir=
branch=master

while getopts D:r:p:o:d: option; do
	case "$option" in
	D)
		debug_level="$OPTARG";;
	d)
		work_dir="$OPTARG";;
	r)
		repo_regex="$OPTARG";;
	p)
		package_regex="$OPTARG";;
	o)
		organization="$OPTARG";;
	*)
		usage "invalid option $option";;
	esac
done
shift $((OPTIND - 1))

if [ -z "$work_dir" ]; then
	usage "no work directory specified"
fi
if [ -z "$organization" ]; then
	usage "no organization specified"
fi
if [ -z "$repo_regex" ]; then
	usage "no repositories specified"
fi
if [ -z "$package_regex" ]; then
	usage "no packages specified"
fi

for dir in "$work_dir"; do
	if [ ! -d "$dir" ]; then
		mkdir -p "$dir" || panic "cannot make directory"
	fi
done

first=1

while true; do

	repo_names=($(ari_gc_lsrepo -o "$organization" | \
	  grep -E '^'"$repo_regex"'$')) || \
	  panic "cannot get list of repositories"
	eecho "number of repositories: ${#repo_names[@]}"
	eecho "repositories:"
	for repo_name in "${repo_names[@]}"; do
		eecho "    $repo_name"
	done
	eecho

	for repo_name in "${repo_names[@]}"; do

		skip=0

		repo_url="ssh://git@github.com/$organization/$repo_name.git"
		#repo_url="https://github.com/$organization/$repo_name.git"
		item_dir="$work_dir/$repo_name"
		commit_id_file="$item_dir/commit_id"
		workspace_dir="$item_dir/workspace"
		repo_dir="$item_dir/repository"
		new_commit_id_file="$workspace_dir/commit_id"
		tmp_file="$workspace_dir/tmp_file"

		cat <<- EOF
		############################################################
		Processing $repo_name
		############################################################
		EOF

		if [ ! -d "$item_dir" ]; then
			mkdir -p "$item_dir" || \
			  panic "cannot make directory $item_dir"
		fi

		for dir in "$repo_dir" "$workspace_dir"; do
			if [ -d "$dir" ]; then
				rm -rf "$dir" || panic "cannot remove directory $dir"
			fi
			mkdir -p "$dir" || \
			  panic "cannot make directory $dir"
		done

		git clone -q "$repo_url" "$repo_dir" || \
		  panic "cannot clone repository $repo_url"

		# Check for an empty repository.
		test -n "$(GIT_DIR="$repo_dir/.git" git rev-list -n 1 --all)"
		if [ $? -ne 0 ]; then
			empty_repo=1
		else
			empty_repo=0
		fi
		if [ "$empty_repo" -ne 0 ]; then
			eecho "warning: skipping empty repository"
			skip=1
		fi

		if [ "$skip" -eq 0 ]; then

			(cd "$repo_dir" && git checkout -q "$branch") || \
			  panic "cannot checkout"
			ari_import1 -v -t git_working_tree -i "$repo_dir" \
			  -d "$workspace_dir"
			status=$?
			if [ "$status" -ne 0 ]; then
				eecho "warning: skipping $repo_name due to import failure"
				skip=1
			fi

		fi

		if [ "$skip" -eq 0 ]; then

			if [ -f "$commit_id_file" ]; then
				commit_id=$(cat "$commit_id_file") || \
				  panic "cannot get commit ID"
			else
				commit_id=
			fi
			new_commit_id=$(cat "$new_commit_id_file") || \
			  panic "cannot get commit ID"
			if [ -z "$new_commit_id" ]; then
				panic "bad commit ID"
			fi

			if [ "$debug_level" -ge 1 ]; then
				eecho "old commit ID: $commit_id"
				eecho "new commit ID: $new_commit_id"
			fi
			if [ -n "$commit_id" -a "$commit_id" = "$new_commit_id" ]; then
				eecho "repository unchanged"
				skip=1
			fi
		fi

		if [ "$skip" -eq 0 ]; then

			ari_process -v "$workspace_dir"
			status=$?

			packages=($((cd "$workspace_dir" && \
			  find . -mindepth 1 -maxdepth 1 -name 'package-*' \
			  -type d -print) | sed -e 's/^\.\/package-//'))

			if [ "$debug_level" -ge 1 ]; then
				eecho "packages:"
				for i in "${packages[@]}"; do
					eecho "    $i"
				done
			fi

			cat > "$tmp_file" <<- EOF
			Status Report:

			This is a test $$.
			Exit status: $status
			EOF
			[ $? -eq 0 ] || panic "cat failed"
			buffer=$(cat "$tmp_file") || panic "cat failed"
			#hub issue create -m "$buffer" || panic "hub failed"

			(cd "$repo_dir" && "$ari_hub" issue)

			echo "$new_commit_id" > "$commit_id_file" || panic

		fi

		if [ "$first" -eq 0 ]; then
			sleep 10
		fi
	done

	first=0

done
