#! /usr/bin/env bash

# __START_OF_LICENSE__
# 
# Copyright (c) 2017 Michael D. Adams
# All rights reserved.
# 
# This file is part of the Aristotle software.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3,
# or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; see the file LICENSE.  If not,
# see <http://www.gnu.org/licenses/>.
# 
# __END_OF_LICENSE__

cmd_dir=$(dirname "$0") || exit 1
source "$cmd_dir/utilities" || exit 1

perror()
{
	echo "ERROR: $@"
}

usage()
{
	if [ $# -gt 0 ]; then
		echo "$@" 1>&2
	fi
	cat <<- EOF
	Usage
	=====

	$0 [options] input_file output_repo

	Options
	=======

	-D debug_level
	    Set the debug level to debug_level.
	-t input_type
	    Set the input type to input_type.
	    Allowed values: dir, zip, tgz
	-v
	    Increase the verbosity level of output.
	-C
	    Disable cleanup.
	EOF
	exit 2
}

user_name=$(whoami) || panic "cannot determine user"
host_name=$(hostname) || panic "cannot determine hostname"
tmp_dir_template="${ARI_TMPDIR:-/tmp}/ari_git_makerepo-${user_name}@${host_name}-$$-XXXXXXXX"

ari_mktemp="$cmd_dir/ari_mktemp"

verbose=0
cleanup=1
debug_level=0
input_type=

while getopts CD:t:v option; do
	case "$option" in
	D)
		debug_level="$OPTARG";;
	t)
		input_type="$OPTARG";;
	v)
		verbose=$((verbose + 1));;
	C)
		cleanup=0;;
	\?)
		usage "invalid option $option";;
	esac
done
shift $((OPTIND - 1))

if [ $# -ne 2 ]; then
	usage "incorrect number of arguments specified"
fi

input="$1"
repo_url="$2"

if [ "$debug_level" -ge 10 ]; then
	set -xv
fi

if [ "$debug_level" -ge 1 ]; then
	discard_stdout=none
	discard_stderr=none
	discard_stdout_stderr=none
else
	discard_stdout=stdout
	discard_stderr=stderr
	discard_stdout_stderr=stdout_stderr
fi

command_status=0
while true; do

	tmp_dir=$("$ari_mktemp" -d "$tmp_dir_template")
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot make temporary directory"
		break
	fi

	if [ "$debug_level" -ge 1 ]; then
		echo "temporary directory: $tmp_dir"
	fi

	# Determine the input type, if necessary.
	if [ -z "$input_type" ]; then
		if [ -d "$input" ]; then
			input_type=dir
		fi
		case "$input_type" in
		*.zip)
			input_type=zip;;
		*.tgz|*.tar.gz)
			input_type=tgz;;
		esac
		if [ -z "$input_type" ]; then
			command_status=1
			perror "could not determine input type"
			break
		fi
	fi

	bare_dir="$tmp_dir/repo.git"
	normal_dir="$tmp_dir/repo"

	for dir in "$bare_dir" "$normal_dir"; do
		mkdir -p "$dir"
		if [ $? -ne 0 ]; then
			command_status=1
			perror "cannot make directory $dir"
			break 2
		fi
	done

	if [ "$verbose" -ge 2 ]; then
		echo "Building temporary repository $bare_dir"
	fi
	(chdir "$bare_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git init --bare .)
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot create bare repository"
		break
	fi
	(chdir "$normal_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git clone "$bare_dir" .)
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot clone bare repository"
		break
	fi

	case "$input_type" in
	dir)
		if [ "$verbose" -ge 2 ]; then
			ls -alR "$input"
		fi
		tar -C "$input" -cf - . | tar -C "$normal_dir" -xf -
		if [ $? -ne 0 ]; then
			command_status=1
			perror "cannot copy files"
			break
		fi
		;;
	zip)
		unzip -q -d "$normal_dir" "$input"
		if [ $? -ne 0 ]; then
			command_status=1
			perror "cannot extract files from zip archive"
			break
		fi
		;;
	tgz)
		tar -x -z -f "$input" -C "$normal_dir"
		if [ $? -ne 0 ]; then
			command_status=1
			perror "cannot extract files from tar archive"
			break
		fi
		;;
	*)
		panic "unknown input type"
		;;
	esac

	(chdir "$normal_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git add .)
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot add files to repository"
		break
	fi
	(chdir "$normal_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git commit -m "Initial commit")
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot commit changes"
		break
	fi
	(chdir "$normal_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git config --local push.default simple)
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot set push.default"
		break
	fi
	(chdir "$normal_dir" && \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git push)
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot push changes"
		break
	fi

	if [ "$verbose" -ge 2 ]; then
		echo "Copying temporary repository to target repository $repo_url"
	fi
#	(chdir "$bare_dir" && \
#	  conditionally_discard_output "$discard_stdout_stderr" \
#	  git push --mirror "$repo_url")
	GIT_DIR="$bare_dir" \
	  conditionally_discard_output "$discard_stdout_stderr" \
	  git push --mirror "$repo_url"
	if [ $? -ne 0 ]; then
		command_status=1
		perror "cannot push to target repository $repo_url"
		break
	fi

	break

done

if [ "$cleanup" -ne 0 -a -d "$tmp_dir" ]; then
	rm -rf "$tmp_dir"
	true
fi

exit "$command_status"
