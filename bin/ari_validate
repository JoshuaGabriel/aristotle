#! /usr/bin/env bash

# __START_OF_LICENSE__
# 
# Copyright (c) 2017 Michael D. Adams
# All rights reserved.
# 
# This file is part of the Aristotle software.
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3,
# or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; see the file LICENSE.  If not,
# see <http://www.gnu.org/licenses/>.
# 
# __END_OF_LICENSE__

cmd_dir=$(dirname "$0") || exit 1
abs_cmd_dir=$(readlink -f "$cmd_dir") || exit 1
source "$cmd_dir/utilities" || exit 1
#etc_dir="$cmd_dir/../etc"

strip_trailing_slashes()
{
	echo "$1" | awk '
		{
			len = length($0);
			while (len >= 1) {
				last = substr($0, len, 1);
				if (last != "/") {
					break;
				}
				--len;
			}
			if (len > 0) {
				print substr($0, 1, len);
			}
		}' -
}

usage()
{
	echo "$@"
	cat <<- EOF
	usage: $0 [options]
	-D debug_level
	    Set the debug level to debug_level.
	-d project_dir
	    Set the project directory to project_directory.
	-v
	    Increase the verbosity level.
	EOF
	exit 2
}

ari_info="$cmd_dir/ari_info"
ari_locate="$cmd_dir/ari_locate"
ari_student_info="$cmd_dir/ari_student_info"
ari_validate_line="$cmd_dir/ari_validate_line"
ari_find_assignment="$cmd_dir/ari_find_assignment"

project_dir=$("$ari_locate" -q) || project_dir=
packages=()
debug_level=${ARI_DEBUG_LEVEL:-0}
verbose=0

while getopts D:d:p:v option; do
	case "$option" in
	D)
		debug_level="$OPTARG";;
	d)
		project_dir="$OPTARG";;
	v)
		verbose=$((verbose + 1));;
	\?)
		usage "invalid option $option";;
	esac
done
shift $((OPTIND - 1))

# Note: The value of project_dir must be an absolute pathname.
# This is necessary to ensure that the various pathnames derived from
# project_dir will be valid, even if the current working directory is
# changed.
project_dir=$(absolute_pathname "$project_dir") || project_dir=

if [ -z "$project_dir" ]; then
	panic "no project directory specified"
fi

project=$(cat "$project_dir/assignment_id") || \
  panic "cannot get assignment ID"
assignment_file=$("$ari_find_assignment" -a "$project") || \
  panic "cannot find assignment $project"
assignment_dir=$(dirname "$assignment_file") || \
  panic "cannot get directory of $assignment_file"

dist_dir="$project_dir/distribution"

num_errors=0

set -f
required_files=($("$ari_info" -a "$project" required_files)) || \
  panic "cannot get required_files property"
whitelisted_files=($("$ari_info" -a "$project" whitelisted_files)) || \
  panic "cannot get whitelisted_files property"
blacklisted_files=($("$ari_info" -a "$project" blacklisted_files)) || \
  panic "cannot get blacklisted_files property"
set +f

if [ "$debug_level" -ge 1 ]; then
	echo "required_files: ${required_files[@]}"
	echo "whitelisted_files: ${whitelisted_files[@]}"
	echo "blacklisted_files: ${blacklisted_files[@]}"
fi

required_file_types=()
for index in "${!required_files[@]}"; do
	file="${required_files[$index]}"
	pathname=$(strip_trailing_slashes "$file") || \
	  panic "cannot strip trailing slashes"
	if [ "$pathname" != "$file" ]; then
		required_file_types[$index]=dir
		required_files[$index]="$pathname"
	else
		required_file_types[$index]=file
	fi
done
whitelisted_files+=("${required_files[@]}")

for index in "${!required_files[@]}"; do
	file="${required_files[$index]}"
	target_file="$dist_dir/$file"
	target_type="${required_file_types[$index]}"
	case "$target_type" in
	file)
		if [ ! -f "$target_file" ]; then
			eecho "ERROR: missing required file $file"
			num_errors=$((num_errors + 1))
		fi
		;;
	dir)
		if [ ! -d "$target_file" ]; then
			eecho "ERROR: missing required directory $file"
			num_errors=$((num_errors + 1))
		fi
		;;
	esac
done

# Ensure that no pathnames contain unprintable characters.
num_files=$(LC_ALL=C find "$dist_dir" -name '*[![:print:]]*' | wc -l) || panic
if [ "$num_files" -gt 0 ]; then
	eecho "ERROR: file/directory names cannot contain unprintable characters"
	num_errors=$((num_errors + 1))
fi

# Ensure that no pathnames contain whitespace characters.
num_files=$(LC_ALL=C find "$dist_dir" -name '*[[:space:]]*' | wc -l) || panic
if [ "$num_files" -gt 0 ]; then
	eecho "ERROR: file/directory names cannot contain whitespace characters"
	num_errors=$((num_errors + 1))
fi

all_files=($(chdir "$dist_dir" && find . -mindepth 1 | sed -e 's/^\.\///'))
for file in "${all_files[@]}"; do
	valid=unknown
	for pattern in "${whitelisted_files[@]}"; do
		if [ "$debug_level" -ge 1 ]; then
			echo "whitelist: testing $file $pattern"
		fi
		[[ "$file" == $pattern ]] && valid=true
	done
	if [ "$valid" = unknown ]; then
		for pattern in "${blacklisted_files[@]}"; do
			if [ "$debug_level" -ge 1 ]; then
				echo "blacklist: testing $file $pattern"
			fi
			[[ "$file" == $pattern ]] && valid=false
		done
	fi
	if [ "$valid" = false ]; then
		eecho "ERROR: invalid file $file"
		num_errors=$((num_errors + 1))
	fi
	if [ "$debug_level" -ge 1 ]; then
		echo "validity check: $file $valid"
	fi
done

student_name_file="$project_dir/student_name"
student_id_file="$project_dir/student_id"
student_email_file="$project_dir/student_email"
section_file="$project_dir/section"
submission_source_file="$project_dir/submission_source"

submission_source=$(cat "$submission_source_file") || \
  panic "cannot get submission source"

saved_ifs="$IFS"
IFS=$'\ca'
student_info_program=($(\
  ARI_BIN_DIR="$abs_cmd_dir" \
  ARI_ASSIGNMENT_DIR="$assignment_dir" \
  ARI_DIST_DIR="$dist_dir" \
  "$ari_info" -a "$project" -e -d "$IFS" student_info_program))
status=$?
IFS="$saved_ifs"
if [ "$status" -ne 0 ]; then
	panic "cannot get property student_info_program"
fi
if [ -z "$student_info_program" ]; then
	student_info_program="$ari_student_info"
fi

student_id_regex=$("$ari_info" -a "$project" student_id_regex) || panic
section_regex=$("$ari_info" -a "$project" section_regex) || panic

if [ "$debug_level" -ge 1 ]; then
	eecho "student ID regex $student_id_regex"
	eecho "section regex $section_regex"
fi

student_name=$( \
  ARI_SUBMISSION_SOURCE="$submission_source" \
  ARI_DIST_DIR="$dist_dir" \
  "$student_info_program" name \
  )
student_name_status=$?
if [ "$student_name_status" -eq 0 ]; then
	"$ari_validate_line" -e '[[:print:]]+' "$student_name"
	student_name_status=$?
fi
if [ "$student_name_status" -eq 0 ]; then
	echo "$student_name" > "$student_name_file"
else
	student_name="Unknown"
	eecho "ERROR: cannot determine student name"
	num_errors=$((num_errors + 1))
fi

student_id=$( \
  ARI_SUBMISSION_SOURCE="$submission_source" \
  ARI_DIST_DIR="$dist_dir" \
  "$student_info_program" student_id \
  )
student_id_status=$?
if [ "$student_id_status" -eq 0 ]; then
	"$ari_validate_line" -e '[[:print:]]+' "$student_id"
	student_id_status=$?
fi
if [ "$student_id_status" -eq 0 -a -n "$student_id_regex" ]; then
	"$ari_validate_line" -D "$debug_level" -e "$student_id_regex" \
	  "$student_id"
	student_id_status=$?
	if [ "$student_id_status" -ne 0 ]; then
		eecho "ERROR: invalid student ID"
		num_errors=$((num_errors + 1))
	fi
fi
if [ "$student_id_status" -ne 0 ]; then
	student_id="Unknown"
	eecho "ERROR: cannot determine student ID"
	num_errors=$((num_errors + 1))
fi
echo "$student_id" > "$student_id_file"

student_email=$( \
  ARI_SUBMISSION_SOURCE="$submission_source" \
  ARI_DIST_DIR="$dist_dir" \
  "$student_info_program" email \
  )
student_email_status=$?
if [ "$student_email_status" -eq 0 ]; then
	"$ari_validate_line" -e '[[:print:]]+' "$student_email"
	student_email_status=$?
fi
if [ "$student_email_status" -eq 0 ]; then
	echo "$student_email" > "$student_email_file"
else
	student_email="Unknown"
	eecho "ERROR: cannot determine student email address"
	num_errors=$((num_errors + 1))
fi

section=$( \
  ARI_SUBMISSION_SOURCE="$submission_source" \
  ARI_DIST_DIR="$dist_dir" \
  "$student_info_program" section \
  )
section_status=$?
if [ "$section_status" -eq 0 ]; then
	"$ari_validate_line" -e '[[:print:]]+' "$section"
	section_status=$?
fi
if [ "$section_status" -eq 0 -a -n "$section_regex" ]; then
	"$ari_validate_line" -D "$debug_level" -e "$section_regex" "$section"
	section_status=$?
	if [ "$section_status" -ne 0 ]; then
		eecho "ERROR: invalid section"
		num_errors=$((num_errors + 1))
	fi
fi
if [ "$section_status" -ne 0 ]; then
	section="Unknown"
	eecho "ERROR: cannot determine section"
	num_errors=$((num_errors + 1))
fi
echo "$section" > "$section_file"

saved_ifs="$IFS"
IFS=$'\ca'
validate_program=($(\
  ARI_BIN_DIR="$abs_cmd_dir" \
  ARI_ASSIGNMENT_DIR="$assignment_dir" \
  ARI_DIST_DIR="$dist_dir" \
  "$ari_info" -a "$project" -e -d "$IFS" validate))
status=$?
IFS="$saved_ifs"
if [ "$status" -ne 0 ]; then
	panic "cannot get validate property"
fi
if [ "${#validate_program[@]}" -ge 1 ]; then
	if [ ! -x "${validate_program[0]}" ]; then
		panic "cannot find validation program ${validate_program[0]}"
	fi
	if [ "$debug_level" -ge 1 ]; then
		eecho "Running ${validate_program[@]}"
	fi
	ARI_BIN_DIR="$abs_cmd_dir" \
	  ARI_ASSIGNMENT_DIR="$assignment_dir" \
	  ARI_DIST_DIR="$dist_dir" \
	  "${validate_program[@]}"
	status=$?
	if [ "$status" -ne 0 ]; then
		eecho "ERROR: additional validation errors"
		num_errors=$((num_errors + 1))
	fi
fi

if [ "$verbose" -ge 1 ]; then
	echo "Student Name: $student_name"
	#echo "Student ID: $student_id"
	echo "Email: $student_email"
	echo "Section: $section"
fi

if [ "$num_errors" -gt 0 ]; then
	echo "validation failed with $num_errors error(s)"
	panic "validation failed"
fi
if [ "$verbose" -ge 1 ]; then
	echo "validation successful"
fi
